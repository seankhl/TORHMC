

\title{Onion Routing}
\author{
        Chris Beavers \& Sean Laguna \\ Department of Computer Science \\ Harvey Mudd College \\ CS 181 Final Project
}
\date{December 7th, 2011}

\documentclass[12pt]{article}

\begin{document}
\maketitle

\begin{abstract}
Onion Routing is a method of anonymizing one's web activity by routing all traffic through an encrypted, random path through a network of ``nodes.'' It was developed as an idea in the late 90s\cite{gold}, and today has gained popularization through the Tor project, whose extensive documentation is available online\cite{tor}. In this paper, we explore the difficulties in implementing an onion routing network, and explore possible security risks with Tor's current model. We conclude by presenting a more secure method of authenticating identity on sites hidden within the network.
\end{abstract}

\section{Implementing Tor}
Our basic approach to constructing an Onion Router stemmed from a description of Tor put forward by Hooks and Miles\cite{hook}. After discussing a plan of attack, we opted to divide the work between us so that Sean worked on encryption while Chris investigated how C sockets and setting up basic connectivity between machines in the network. Consequently, Sean explored a myriad of different encryption algorithms discussed in class and implemented in the OpenSSL library, while Chris began to grapple with sockets in C to establish paths on the fly through the network. Both avenues had significant learning curves, but the final code is available via a git repository at {\tt https://github.com/seanlaguna/TORHMC}.

\paragraph{Current Functionality}
Currently, our implementation has three different operators: clients, nodes, and designated exit nodes. A client begins by selecting a random set of available nodes and their corresponding RSA public keys from a comprehensive list of nodes on the network. The client then constructs an initiation onion, encrypted with all public keys. This onion is relayed to the first node in the path, who notes a new socket connection, accepts, and then receives a buffer which it decrypts with its private key.

The header of the unencrypted buffer contains information for where the next node in the path is, and how to connect to it. In addition, it contains a pre-established symmetric key for this node to use in decrypting future messages. This node then sets up a socket connection with the next node and relays the remainder of the encrypted onion.

This process continues until a pre-decided exit node is reached, which finishes the process by getting the original plaintext, which is by now just an empty buffer. The path is then set up for symmetric relaying, and the client may put in web addresses to quickly and anonymously ping.

When an address is entered from the client, it is encrypted in reverse order with all of the path's symmetric keys. Each node then peels off a layer as it passes through, and the exit node decrypts plaintext containing the web address to ping. Currently, it just issues a system command to do this and checks to see if it errors. The ping's success or failure is then relayed back through the path, being encrypted at each layer. The client then peels off all layers with the symmetric keys to reveal the response.

Our method of path-selection is currently hard-coded, but we have set up the code in such a way that implementing random path creation should be simple. By storing a list of available nodes, ports, and public keys, the client could just pick some number of them and establish a path.

\paragraph{Unimplemented Features}
As is apparent from the description above, our implementation does not attempt to acquire all outgoing Internet traffic to route through the onion network. Conversations with our professors revealed this to be far out of the scope of our project, requiring the client node to somehow monitor at a very low level all system activity, construct an effective packeting scheme for this activity to feed it through the onion network, and the ability of the exit node to emulate an ethernet connection to relay the outgoing message. In essence, we would have to write the code for setting up a VPN, but have all of the traffic for its operation run through our network. A dissertation maybe, but not a final project.

\paragraph{Challenges}
The primary challenges that this project presented were
\begin{enumerate}
\item Developing an expertise with C sockets
\item Understanding and implementing the OpenSSL library
\item Combining Chris' C socket code with Sean's C++ OpenSSL encrypt/decrypt functions
\end{enumerate}
These challenges arose out of the decision to split our original Roadmap goals into two distinct tracks. Chris adopted the challenge of routing traffic, and Sean explored security implementations, ultimately managing to navigate the quagmire that is the undocumented OpenSSL library.

Primarily, the fact that encryption/decryption changes the size of the text was difficult to integrate with the fixed-size buffer relaying of C sockets. While it is possible that we could have written code to read multiple buffers as the message grew, it was much simpler in practice to just regulate the size of the text passed and ensure that it never exceeded the capacity of our underlying buffer.

\section{Improving Tor}
A major problem challenging Tor today is the ease with which phishing sites may be anonymously established to emulate other hidden Tor sites. Internal Tor URLs consist of large strings of random characters that it is nearly impossible to remember or verify by sight. Furthemore, they change over time to ensure anonymity. Consequently, by creating a look-alike login and posting it on the Internet for possible Tor explorers to see reveals a large base of people uncertain if they're logging into the correct service or not.

While phishing is essentially impossible to avoid on first visit to a site (as one is unfamiliar with the site and must of course set up an account before using it, etc.), return visitors should have some form of method for verifying the site's authenticity. To this end, we take a page from the bank's playbook, and propose that some form of verifying signature be established on first visit that can be reused on return visits. Keeping this interaction anonymous is, of course, the trick, as most such identifying features used by banks rely on IP address on information about the client machine.

Simple enough, we propose that on the first visit to a new login-based site, the user establishes a shared key with the site which both parties save, the server associating it with the user's encrypted ID. Upon future visits, the user sends their encrypted ID, the site receives it and writes a response with the shared key, and the user decrypts that to become assured that they have actually made contact with the site. Furthermore, they may establish session keys at this point to ensure that no one can perform an effective man-in-the-middle attack.

Our approach does indeed provide the possibility of a man being in the middle, but on an onion network this seems inescapable. This man may only relay encrypted traffic at all times though, so they can't garner anything private from the exchange, pending their inability to break the encryption. Using modern cryptographic systems, this process should ensure a secure connection to hidden Tor sites.

\section{Conclusions}
Doing this is smart because duh.

\bibliographystyle{plain}

\begin{thebibliography}{1}

  \bibitem{gold} Goldschlag, David, Michael Reed, and Paul Syverson. ``Onion Routing: for Anonymous and Private Internet Connections." {\it Communications of the ACM} 42.2 (1999). PDF.
  
  \bibitem{tor} {\it Tor Project}: Anonymity Online. Web. 03 Dec. 2011. $<${\tt http://www.torproject.org}$>$.

  \bibitem{hook}  Hooks, Matt, and Jadrian Miles. ``Onion Routing and Online Anonymity." (2006). {\it Duke University}. Web.

  \end{thebibliography}


\end{document}
